package ru.job4j.multithread;

import net.jcip.annotations.GuardedBy;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ThreadPoolExecutor;

/**
 * класс ThreadPool. Создает указанное в конструкторе количество потоков выполняет переданную работу.
 *
 * @author Dmitriy Balandin (d89086362742@yandex.ru)
 * @version $Id$
 * @since 30.05.2018
 */
public class ThreadPool {

    /**
     * Отображает желание прекратить работу потоков, потоки не зыкрываются сразу, они доделывают всю работу в очереди и текущую
     */
    private boolean worked = true;

    /**
     * Хранит ссылки на созданные в конструкторе потоки
     */
    private Thread[] threads;

    /**
     * Хранит работу для потоков, также является монитором для потоков
     */
    @GuardedBy("works")
    private final Queue<Runnable> works;

    /**
     * Запускает потоки, которые просматривают очередь и берут из нее работу. Если здесь запустить join программа на нем
     * останавливается и не продолжает свою работу, так как начинает ожидать окончания бесконечного потока.
     *
     * @param volume количество потоков, не должно быть ниже 1. Можно поставить на значение 0 и ниже исключение.
     */
    public ThreadPool(int volume) {
        works = new LinkedList<Runnable>();
        threads = new Thread[volume];
        for (int index = 0; index < volume; index++) {
            threads[index] = new Thread(new Work());
            threads[index].start();
        }
    }

    /**
     * Берет монитор, добавляет в очередь значение и будит поток для выполнения работы если он в состоянии wait()
     *
     * @param work
     */
    public void add(Runnable work) {
        synchronized (works) {
            works.offer(work);
            works.notify();
        }
    }

    /**
     * Основной поток меняет флаг на закрывающий, потоки продолжают свою работу пока не опустеет очередь задач и они не
     * доделают всю работу затем они "умрут", а основной поток дождется смерти всех потоков методом join и только после этого
     * закончит свою работу. Это сделано чтобы основная нить дожидалась окончания работы программы. В реальном приложении
     * если поток main в бесконечном ожидании пользователя это врят ли понадобится.
     *
     * @throws InterruptedException
     */
    public void close() throws InterruptedException {
        worked = false;
        for (Thread thread : threads) {
            thread.join();
        }
    }


    /**
     * Ввнутренний клас для инициализации бесконечного потока, запрашивающего работу из очереди,
     * хотя можно было его унаследовать от Thread и сделать потоком сразу.
     * если флаг worked падает, то поток продолжает работать пока не сделает всю начатую работу и работу в очереди.
     * Можно было конечно реализовать завершение с помощью флага потока и прерыванием interrapt().
     * Предыдущей ошибкой было распространить блок монитора на nextWork.run(); эта ошибка приводило к тому что поток отпускал монитор
     * только тогда, когда заканчивал работу, что приводило к работе только одного потока, так как все остальные ждали когда он закончит работу и отпустит монитор
     * естессственно что метод notify не помогал никого протолкнуть, так ккак объект продолжал быть заблокирован
     * Блокировку объекта пришлось сделать, так как потоки начинали раздирать очередь, и пропускать некоторые объекты,
     * но мне кажется что это было вызвано другой ошибкой, и еще когда не было ожидания потоки постоянно просили работы и межали поставщику работы основному потоку подать
     * информацию в очередь. И тогда приходилось долго ожидать пока главный потоко наконец получал возможность что либо добавить в очередь
     * 100 мс можно убрать из wait(), но тогда потоки могут заблокироваться и не умирать, хотя если организовать смерть при обработке прерывания interrapt то проблем не будет, хотя непонятно как проверять окончена потоком работа
     * Проверку на размер можно было бы убрать, но при тестах нужно было доводить работу до конца для чистоты эксперимента.
     * Частой и трудно обнаруживаемой ошибкой было бесконечная работа программы. Я думаю это происходило по той причине, что я использовал для ожидания join, но видимо потоки не умирали застревая на wait. хотя в предыдущем задании этого не происходило, нужно подумать об этом позже.
     */
    class Work implements Runnable {
        @Override
        public void run() {
            Runnable nextWork;
            int size = 1;
            while (worked || size != 0) {
                synchronized (works) {
                    nextWork = works.poll();
                    if (nextWork == null && worked) {
                        try {
                            works.wait(100);
                        } catch (InterruptedException ie) {
                            System.out.println("return");
                            return;
                        }
                    }

                }
                if (nextWork != null) {
                    nextWork.run();
                }
                synchronized (works) {
                    size = works.size();
                }
            }
        }
    }
}


